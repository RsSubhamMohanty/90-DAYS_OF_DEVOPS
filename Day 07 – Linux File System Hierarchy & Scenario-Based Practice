Part 1: Linux File System Hierarchy

ðŸ“‚ Core Directories
/ (root): The top-level directory. Everything starts here.
Seen via ls: bin, boot, dev, etc, home, proc.
Use case: I use this to navigate to any part of the system.

/home: Contains personal folders for regular users.
Seen via ls: ubuntu (or your username).
Use case: I use this to store my personal scripts and project files.

/root: The home directory specifically for the root (admin) user.
Seen via ls: .bashrc, .profile.
Use case: I use this when Iâ€™m logged in as the superuser to manage system-wide tasks.

/etc: The heart of configuration.
Seen via ls: passwd, group, network.
Use case: I would use this to change the server's hostname or edit Nginx/Docker configs.

/var/log: Where the system and apps "complain."
Seen via ls: syslog, auth.log, dpkg.log.
Use case: This is my first stop when a service fails to start.

/tmp: Temporary storage. Files here are usually deleted on reboot.
Seen via ls: apt-*-lock.
Use case: I use this for throwaway test files or intermediate script outputs.

ðŸ” Hands-on Exploration
Hostname: cat /etc/hostname -> Shows [container-id].
Largest Log: du -sh /var/log/* 2>/dev/null | sort -h | tail -1 -> Usually journal or dpkg.log in a fresh container.

Part 2: Scenario Practice

Scenario 1: Service Not Starting (myapp)

Step 1: systemctl status myapp
Why: To see if it's "failed" or "inactive" and catch the immediate error message. Step 2: journalctl -u myapp -n 50
Why: To read the specific logs generated by the application at the moment it crashed. Step 3: systemctl is-enabled myapp
Why: To check if the service was even supposed to start automatically after the reboot. Step 4: tail -f /var/log/syslog
Why: To see if system-wide issues (like out-of-memory errors) are killing the service.

Scenario 2: High CPU Usage

Step 1: top (then press P to sort by CPU)
Why: Gives a live, interactive view of which process is "hogging" the CPU. Step 2: ps aux --sort=-%cpu | head -10
Why: Provides a non-interactive snapshot of the top 10 CPU-consuming processes. Step 3: htop (if installed)
Why: Easier to read than top and allows me to see CPU usage per core.

Scenario 3: Finding Service Logs (docker)

Step 1: systemctl status docker
Why: Often the last few lines of the log are shown right in the status output. Step 2: journalctl -u docker -n 50
Why: To view the most recent 50 events specific to the Docker daemon. Step 3: journalctl -u docker -f
Why: To watch the logs in real-time while I try to start a container to see exactly when it fails.

Scenario 4: File Permissions Issue (backup.sh)

Step 1: ls -l backup.sh
Why: To confirm the current permissions (e.g., -rw-r--r-- shows no x for execute). Step 2: chmod +x backup.sh
Why: To add the "Execute" permission for the owner, group, and others. Step 3: ls -l backup.sh
Why: To verify the permissions changed to -rwxr-xr-x (the filename will likely turn green). Step 4: ./backup.sh
Why: To finally run the script and confirm the "Permission denied" error is gone.

